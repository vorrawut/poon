---
description: React Development Rules & Project Structure Guide
globs: ["**/*.tsx", "**/*.ts", "**/*.jsx", "**/*.js"]
alwaysApply: true
---

# React Development Rules & Project Structure Guide

## ğŸ—ï¸ **MANDATORY PROJECT STRUCTURE**

### **1. Feature-Based Architecture (REQUIRED)**
```
src/
â”œâ”€â”€ app/                    # App-level bootstrap, routes, providers
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ routes.tsx
â”‚   â””â”€â”€ providers/          # ThemeProvider, AuthProvider, i18n
â”œâ”€â”€ features/              # Feature-based domains (MAIN ORGANIZATION)
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”œâ”€â”€ ui/           # Pages and route containers
â”‚   â”‚   â”œâ”€â”€ components/   # Feature-specific components
â”‚   â”‚   â”œâ”€â”€ hooks/        # Feature-specific hooks
â”‚   â”‚   â”œâ”€â”€ services/     # Feature API clients
â”‚   â”‚   â”œâ”€â”€ types/        # Feature types
â”‚   â”‚   â””â”€â”€ index.ts      # Feature exports
â”œâ”€â”€ components/           # Global atomic components (Button, Input)
â”œâ”€â”€ widgets/             # Composite components (Charts, Cards)
â”œâ”€â”€ services/            # Global API clients and adapters
â”œâ”€â”€ styles/              # Design tokens, themes, global CSS
â”‚   â”œâ”€â”€ tokens/          # Color, spacing, typography tokens
â”‚   â””â”€â”€ index.css
â”œâ”€â”€ libs/                # Pure utilities (no React dependencies)
â”œâ”€â”€ hooks/               # Cross-feature hooks
â”œâ”€â”€ types/               # Global app types (use sparingly)
â””â”€â”€ tests/               # Common test fixtures
```

### **2. Mock Data Organization (CRITICAL RULE)**
```
mockData/                 # ALL mock data MUST be here, NEVER in /src
â”œâ”€â”€ common/              # Shared configurations, accounts, transactions
â”‚   â””â”€â”€ data.ts
â””â”€â”€ features/           # Feature-specific mock data
    â”œâ”€â”€ dashboard/
    â”‚   â”œâ”€â”€ dashboardData.ts
    â”‚   â””â”€â”€ index.ts
    â”œâ”€â”€ portfolio/
    â”‚   â”œâ”€â”€ portfolioData.ts
    â”‚   â”œâ”€â”€ portfolioDetailData.ts
    â”‚   â””â”€â”€ index.ts
    â”œâ”€â”€ spending/
    â”‚   â”œâ”€â”€ moneyFlowData.ts
    â”‚   â”œâ”€â”€ spendingData.ts
    â”‚   â””â”€â”€ index.ts
    â””â”€â”€ widgets/
        â”œâ”€â”€ widgetsData.ts
        â””â”€â”€ index.ts
```

**ğŸš¨ CRITICAL RULES:**
- **NO mock data allowed in `/src` directory**
- **ALL mock data MUST be in `/mockData` organized by features**
- **Use centralized imports from `/mockData` only**
- **Each feature has its own mock data folder**

## ğŸ“¦ **COMPONENT TAXONOMY**

### **Atoms (components/)**
- **Purpose**: Tiny presentational components (Button, Icon, Typography)
- **Rules**: No side effects, highly reusable
- **Tests**: Unit + snapshot
- **Example**: `<Button>`, `<Input>`, `<Icon>`

### **Molecules (components/widgets/)**
- **Purpose**: Small compositions (InputWithLabel, SearchBox)
- **Rules**: Combine atoms, minimal logic
- **Tests**: Unit + integration

### **Widgets (widgets/)**
- **Purpose**: Complex composites with logic (Charts, DataTables)
- **Rules**: Business logic, API interactions, state management
- **Tests**: Integration tests

### **Feature UI (features/*/ui)**
- **Purpose**: Pages, route containers, feature orchestration
- **Rules**: Wire services/state together, handle routing
- **Tests**: Integration & E2E

## ğŸ¯ **IMPORT/EXPORT RULES**

### **Feature Exports**
```typescript
// features/portfolio/index.ts
export { Portfolio } from "./ui/Portfolio";
export { PortfolioDetail } from "./ui/PortfolioDetail";
export { usePortfolio } from "./hooks/usePortfolio";
export type { PortfolioAsset } from "./types";
```

### **Mock Data Imports**
```typescript
// âœ… CORRECT - Import from centralized mockData
import { mockPortfolioAssets } from "../../../../mockData/features/portfolio";

// âŒ WRONG - Local mock data in components
const mockData = [...]; // NEVER DO THIS
```

### **Import Patterns**
- **Within features**: Use relative imports
- **Cross-feature**: Use absolute imports from feature index
- **Mock data**: Always from `/mockData` structure

## ğŸ§ª **TESTING STRATEGY**

### **Unit Tests (Vitest + RTL)**
- **Location**: Co-locate with components
- **Pattern**: `Component.test.tsx` next to `Component.tsx`
- **Focus**: Component behavior, props, rendering

### **Integration Tests**
- **Purpose**: Multiple components together
- **Tools**: RTL + Vitest + MSW for API mocking
- **Focus**: Feature workflows, user interactions

### **E2E Tests (Playwright)**
- **Location**: `/e2e` directory
- **Focus**: Critical user flows, auth, payments
- **Strategy**: Minimal but high-value coverage

## ğŸ¨ **STYLING PATTERNS**

### **Tailwind Usage**
```typescript
// âœ… GOOD - Semantic wrapper classes
.btn-primary { @apply px-4 py-2 rounded-md font-medium bg-blue-500; }

// âœ… GOOD - Design tokens
const colors = {
  primary: "#6366F1",
  secondary: "#8B5CF6",
};

// âŒ AVOID - Long utility chains in JSX
<div className="px-4 py-2 bg-blue-500 text-white rounded-md font-medium hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
```

### **Component Styling**
- Use semantic CSS classes for repeated patterns
- Keep design tokens in `/src/styles/tokens/`
- Prefer component-level styling over global styles

## ğŸ”§ **TYPESCRIPT RULES**

### **Type Organization**
```typescript
// âœ… GOOD - Feature-specific types
// features/portfolio/types/index.ts
export interface PortfolioAsset {
  id: string;
  name: string;
  value: number;
}

// âœ… GOOD - String unions over enums
export type ButtonVariant = 'primary' | 'secondary' | 'ghost';

// âŒ AVOID - Runtime enums (use const assertions)
enum ButtonVariant { Primary, Secondary } // Avoid
```

### **Type Safety**
- Keep types close to domain (in feature folders)
- Export common types from `types/` sparingly
- Use string unions over enums for cross-bundle safety

## ğŸ—‚ï¸ **STATE MANAGEMENT**

### **Global State**
- **Server State**: React Query (TanStack Query)
- **UI State**: Zustand or React Context
- **Location**: Co-locate with features

### **State Patterns**
```typescript
// âœ… GOOD - Feature-specific store
// features/portfolio/hooks/usePortfolio.ts
export const usePortfolio = () => {
  // Feature-specific state logic
};

// âœ… GOOD - Query keys with features
// features/portfolio/hooks/usePortfolioQuery.ts
const portfolioKeys = {
  all: ['portfolio'] as const,
  lists: () => [...portfolioKeys.all, 'list'] as const,
};
```

## ğŸ“ **FILE NAMING CONVENTIONS**

### **Components**
- **React Components**: PascalCase (`PortfolioCard.tsx`)
- **Utilities**: camelCase (`formatCurrency.ts`)
- **Types**: PascalCase (`PortfolioTypes.ts`)
- **Tests**: Match component name (`PortfolioCard.test.tsx`)

### **Features**
- **Feature folders**: lowercase with hyphens (`money-flow/`)
- **Feature exports**: PascalCase (`MoneyFlow.tsx`)
- **Services**: camelCase (`portfolioService.ts`)

## ğŸš€ **DEVELOPMENT WORKFLOW**

### **Adding New Features**
1. Create feature folder: `src/features/feature-name/`
2. Add subfolders: `ui/`, `components/`, `hooks/`, `services/`, `types/`
3. Create mock data: `mockData/features/feature-name/`
4. Export from feature index: `src/features/feature-name/index.ts`
5. Add tests co-located with components
6. Update routes in `src/app/routes.tsx`

### **Mock Data Workflow**
1. **NEVER** create mock data in `/src`
2. Add to appropriate `/mockData/features/[feature]/`
3. Export from feature mock data index
4. Import in components from centralized location
5. Update main `/mockData/index.ts` if needed

## ğŸ” **CODE QUALITY RULES**

### **Component Rules**
```typescript
// âœ… GOOD - Clean component structure
export function PortfolioCard({ asset }: PortfolioCardProps) {
  const { data, isLoading } = usePortfolioQuery();
  
  if (isLoading) return <Skeleton />;
  
  return (
    <Card>
      <CardHeader>{asset.name}</CardHeader>
      <CardContent>{formatCurrency(asset.value)}</CardContent>
    </Card>
  );
}

// âŒ AVOID - Inline styles, complex logic in render
export function BadComponent() {
  return (
    <div style={{ padding: '16px' }}> {/* Use Tailwind/CSS classes */}
      {/* Complex logic here */}
    </div>
  );
}
```

### **Performance Rules**
- Use `React.memo()` for expensive components
- Implement proper loading states
- Use `useMemo()` and `useCallback()` judiciously
- Lazy load routes and heavy components

### **Accessibility Rules**
- Always include proper ARIA labels
- Ensure keyboard navigation works
- Use semantic HTML elements
- Test with screen readers

## ğŸ“‹ **MANDATORY CHECKLIST**

### **Before Creating Components**
- [ ] Is this an atom, molecule, widget, or feature UI?
- [ ] Where should it live in the component taxonomy?
- [ ] Does it need mock data? (Add to `/mockData`)
- [ ] What tests does it need?

### **Before Adding Mock Data**
- [ ] Is it in `/mockData` (NOT `/src`)?
- [ ] Is it organized by feature?
- [ ] Is it exported from feature index?
- [ ] Are imports updated to use centralized location?

### **Before Committing**
- [ ] All tests pass (`npm test`)
- [ ] Linting passes (`npm run lint`)
- [ ] TypeScript compiles (`npm run build`)
- [ ] No mock data in `/src` directory
- [ ] Components follow taxonomy rules
- [ ] Proper imports/exports structure

## ğŸ¯ **PERFORMANCE & UX**

### **Loading States**
- Always show skeleton loaders
- Implement proper error boundaries
- Use Suspense for code splitting
- Handle offline states gracefully

### **User Experience**
- Implement optimistic updates
- Provide immediate feedback
- Use animations for state transitions
- Ensure responsive design works on all devices

## ğŸ”’ **SECURITY & BEST PRACTICES**

### **Data Handling**
- Sanitize user inputs
- Validate props with TypeScript
- Handle API errors gracefully
- Never expose sensitive data in client code

### **Code Organization**
- Keep components focused and single-purpose
- Extract custom hooks for reusable logic
- Use proper error boundaries
- Implement proper logging for debugging

---

**ğŸš¨ CRITICAL REMINDERS:**
1. **NO MOCK DATA IN `/src`** - Always use `/mockData` structure
2. **Feature-based organization** - Group by domain, not file type
3. **Co-locate tests** - Keep tests next to components
4. **Export through index files** - Clean public APIs
5. **Follow component taxonomy** - Atoms â†’ Molecules â†’ Widgets â†’ Features

This structure ensures maintainability, testability, and scalability for long-term development success.